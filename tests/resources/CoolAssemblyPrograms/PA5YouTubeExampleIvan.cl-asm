
;;start Bool's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
Bool..vtable:
	constant string1
	constant Bool..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
;;start IO's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
IO..vtable:
	constant string2
	constant IO..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
	constant IO.in_int
	constant IO.in_string
	constant IO.out_int
	constant IO.out_string
;;start Int's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
Int..vtable:
	constant string3
	constant Int..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
;;start Main's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
Main..vtable:
	constant string4
	constant Main..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
	constant IO.in_int
	constant IO.in_string
	constant IO.out_int
	constant IO.out_string
	constant Main.main
;;start Object's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
Object..vtable:
	constant string5
	constant Object..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
;;start String's vtable;;;;;;;;;;;;;;;;;;;;;;;;;;
String..vtable:
	constant string6
	constant String..new
	constant Object.abort
	constant Object.copy
	constant Object.type_name
	constant String.concat
	constant String.length
	constant String.substr
;;start Bool's constructor;;;;;;;;;;;;;;;;;;;;;
Bool..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 4
	alloc r0 r0
	li r2 <- 23
	st r0[0] <- r2
	li r2 <- 4
	st r0[1] <- r2
	la r2 <- Bool..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
	;;this is 1 of 3 basic classes. Only one attribute, which is the unboxed raw
	;;self[3] holds attr rawBool (Bool), DON'T construct a new Bool. Just save raw value
	li r1 <- 0
	st r0[3] <- r1
Bool..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start IO's constructor;;;;;;;;;;;;;;;;;;;;;
IO..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 3
	alloc r0 r0
	li r2 <- 5
	st r0[0] <- r2
	li r2 <- 3
	st r0[1] <- r2
	la r2 <- IO..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
IO..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start Int's constructor;;;;;;;;;;;;;;;;;;;;;
Int..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 4
	alloc r0 r0
	li r2 <- 21
	st r0[0] <- r2
	li r2 <- 4
	st r0[1] <- r2
	la r2 <- Int..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
	;;this is 1 of 3 basic classes. Only one attribute, which is the unboxed raw
	;;self[3] holds attr rawInt (Int), DON'T construct a new Bool. Just save raw value
	li r1 <- 0
	st r0[3] <- r1
Int..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start Main's constructor;;;;;;;;;;;;;;;;;;;;;
Main..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 5
	alloc r0 r0
	li r2 <- 25
	st r0[0] <- r2
	li r2 <- 5
	st r0[1] <- r2
	la r2 <- Main..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
	;;self[3] holds attr a (Int), so construct a new Int
	;;Caller calling conventions;;;;;;;
	push fp
	push r0
	la r2 <- Int..new
	call r2
	;;Caller return conventions;;;;;;;;
	pop r0
	pop fp
	st r0[3] <- r1
	;;self[4] holds attr b (Int), so construct a new Int
	;;Caller calling conventions;;;;;;;
	push fp
	push r0
	la r2 <- Int..new
	call r2
	;;Caller return conventions;;;;;;;;
	pop r0
	pop fp
	st r0[4] <- r1
	;;self[3] a (Int) initializer
	;;new Int for initializer expression;;;;;;;;;
	;;Caller calling conventions;;;;;;;
	push fp
	push r0
	la r2 <- Int..new
	call r2
	;;Caller return conventions;;;;;;;;
	pop r0
	pop fp
	;;evaluate Int expression and store;;;;;;;;;;;;;;;;;
	li r2 <- 222
	st r1[3] <- r2
	;;store result of creating object from initializer expression;;;;;;;;;;
	st r0[3] <- r1
	;;self[4] b (Int) initializer
	;;new Int for initializer expression;;;;;;;;;
	;;Caller calling conventions;;;;;;;
	push fp
	push r0
	la r2 <- Int..new
	call r2
	;;Caller return conventions;;;;;;;;
	pop r0
	pop fp
	;;evaluate Int expression and store;;;;;;;;;;;;;;;;;
	li r2 <- 333
	st r1[3] <- r2
	;;store result of creating object from initializer expression;;;;;;;;;;
	st r0[4] <- r1
Main..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start Object's constructor;;;;;;;;;;;;;;;;;;;;;
Object..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 3
	alloc r0 r0
	li r2 <- 0
	st r0[0] <- r2
	li r2 <- 3
	st r0[1] <- r2
	la r2 <- Object..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
Object..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start String's constructor;;;;;;;;;;;;;;;;;;;;;
String..new:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;alloc then store classTag->objectSize->vtable->attributes in that order;;;;;;;;;;
	li r0 <- 4
	alloc r0 r0
	li r2 <- 13
	st r0[0] <- r2
	li r2 <- 4
	st r0[1] <- r2
	la r2 <- String..vtable
	st r0[2] <- r2
	;; now start attributes. make new default objects;;;;;;;;;;;
	;;this is 1 of 3 basic classes. Only one attribute, which is the unboxed raw
	;;self[3] holds attr rawString (String), DON'T construct a new Bool. Just save raw value
	la r1 <- the.empty.string
	st r0[3] <- r1
String..new.end:
	;;callee return conventions;;;;;;;
	mov r1 <- r0
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
;;start method generation;;;;;;;;;;
Object.abort:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    la r1 <- abort
    syscall IO.out_string
    syscall exit
Object.abort.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
Object.copy:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    ld r2 <- r0[1]
    alloc r1 r2
    push r1
l1:
    bz r2 l2
    ld r3 <- r0[0]
    st r1[0] <- r3
    li r3 <- 1
    add r0 <- r0 r3
    add r1 <- r1 r3
    li r3 <- 1
    sub r2 <- r2 r3
    jmp l1
l2:
    ;; done with Object.copy loop
    pop r1
Object.copy.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
Object.type_name:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- String..new
    call r2
    pop r0
    pop fp
    ;; obtain vtable for self object
    ld r2 <- r0[2]
    ;; look up type name at offset 0 in vtable
    ld r2 <- r2[0]
    st r1[3] <- r2
Object.type_name.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
IO.in_int:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- Int..new
    call r2
    pop r0
    pop fp
    mov r2 <- r1
    syscall IO.in_int
    st r2[3] <- r1
    mov r1 <- r2
IO.in_int.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
IO.in_string:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- String..new
    call r2
    pop r0
    pop fp
    mov r2 <- r1
    syscall IO.in_string
    st r2[3] <- r1
    mov r1 <- r2
IO.in_string.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
IO.out_int:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    ld r2 <- fp[2]
    ld r1 <- r2[3]
    syscall IO.out_int
    mov r1 <- r0
IO.out_int.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 2
	add sp <- sp r2
	return
IO.out_string:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    ld r2 <- fp[2]
    ld r1 <- r2[3]
    syscall IO.out_string
    mov r1 <- r0
IO.out_string.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 2
	add sp <- sp r2
	return
String.concat:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- String..new
    call r2
    pop r0
    pop fp
    mov r3 <- r1
    ld r2 <- fp[2]
    ld r2 <- r2[3]
    ld r1 <- r0[3]
    syscall String.concat
    st r3[3] <- r1
    mov r1 <- r3
String.concat.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 2
	add sp <- sp r2
	return
String.length:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- Int..new
    call r2
    pop r0
    pop fp
    mov r2 <- r1
    ld r1 <- r0[3]
    syscall String.length
    st r2[3] <- r1
    mov r1 <- r2
String.length.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 1
	add sp <- sp r2
	return
String.substr:
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 1;;;;;;;;;;
	li r2 <- 1
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
    push fp
    push r0
    la r2 <- String..new
    call r2
    pop r0
    pop fp
    mov r3 <- r1
    ld r2 <- fp[2]
    ld r2 <- r2[3]
    ld r1 <- fp[3]
    ld r1 <- r1[3]
    ld r0 <- r0[3]
    syscall String.substr
    bnz r1 l3
    la r1 <- substr
    syscall IO.out_string
    syscall exit
l3:
    st r3[3] <- r1
    mov r1 <- r3
String.substr.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 3
	add sp <- sp r2
	return
Main.main:
	;;method definition;;;;;;;;;;;
	;;Callee calling conventions;;;;;;;;;;;;;;
	mov fp <- sp
	pop r0
	;; stack room for temps: 2;;;;;;;;;;
	li r2 <- 2
	sub sp <- sp r2
	push ra
	;;method body begins;;;;;;;;;;;
	;;PLACEHOLDER FOR METHOD BODY
	push r0
	push fp
	;;identifier: a
	ld r1 <- r0[3]
	ld r1 <- r1[3]
	st fp[0] <- r1
	;;identifier: b
	ld r1 <- r0[4]
	ld r1 <- r1[3]
	ld r2 <- fp[0]
	add r1 <- r2 r1
	st fp[0] <- r1
	;;Caller calling conventions;;;;;;;
	push fp
	push r0
	la r2 <- Int..new
	call r2
	;;Caller return conventions;;;;;;;;
	pop r0
	pop fp
	ld r2 <- fp[0]
	st r1[3] <- r2
	push r1
	push r0
	;;obtain vtable for self object of type Main
	ld r2 <- r0[2]
	;;look up out_int at offset 7
	ld r2 <- r2[7]
	call r2
	pop fp
	pop r0
	;;method body ends;;;;;;;;;;;
Main.main.end:
	;;callee return conventions;;;;;;;
	pop ra
	li r2 <- 2
	add sp <- sp r2
	return
;;end method generation;;;;;;;;;;
;;global string constants;;;;;;;;;;;;;
the.empty.string:
	constant ""
abort:
	constant "abort!\n"
substr:
	constant "ERROR: 0: Exception: String.substr out of range\n"
string1:
	constant "Bool"
string2:
	constant "IO"
string3:
	constant "Int"
string4:
	constant "Main"
string5:
	constant "Object"
string6:
	constant "String"
;;start helper subroutines;;;;;;;;;;;;;;;;;;;;;;;;;;;
eq_handler:             ;; helper function for =
                        mov fp <- sp
                        pop r0
                        push ra
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        beq r1 r2 eq_true
                        li r3 <- 0
                        beq r1 r3 eq_false
                        beq r2 r3 eq_false
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        ;; place the sum of the type tags in r1
                        add r1 <- r1 r2
                        li r2 <- 0
                        beq r1 r2 eq_bool
                        li r2 <- 2
                        beq r1 r2 eq_int
                        li r2 <- 6
                        beq r1 r2 eq_string
                        ;; otherwise, use pointer comparison
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        beq r1 r2 eq_true
eq_false:               ;; not equal
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        jmp eq_end
eq_true:                ;; equal
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        li r2 <- 1
                        st r1[3] <- r2
                        jmp eq_end
eq_bool:                ;; two Bools
eq_int:                 ;; two Ints
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        beq r1 r2 eq_true
                        jmp eq_false
eq_string:              ;; two Strings
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        beq r1 r2 eq_true
                        jmp eq_false
eq_end:                 pop ra
                        li r2 <- 2
                        add sp <- sp r2
                        return
                        ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
le_handler:             ;; helper function for <=
                        mov fp <- sp
                        pop r0
                        push ra
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        beq r1 r2 le_true
                        li r3 <- 0
                        beq r1 r3 le_false
                        beq r2 r3 le_false
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        ;; place the sum of the type tags in r1
                        add r1 <- r1 r2
                        li r2 <- 0
                        beq r1 r2 le_bool
                        li r2 <- 2
                        beq r1 r2 le_int
                        li r2 <- 6
                        beq r1 r2 le_string
                        ;; for non-primitives, equality is our only hope
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        beq r1 r2 le_true
le_false:               ;; not less-than-or-equal
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        jmp le_end
le_true:                ;; less-than-or-equal
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        li r2 <- 1
                        st r1[3] <- r2
                        jmp le_end
le_bool:                ;; two Bools
le_int:                 ;; two Ints
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        ble r1 r2 le_true
                        jmp le_false
le_string:              ;; two Strings
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        ble r1 r2 le_true
                        jmp le_false
le_end:                 pop ra
                        li r2 <- 2
                        add sp <- sp r2
                        return
                        ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
lt_handler:             ;; helper function for <
                        mov fp <- sp
                        pop r0
                        push ra
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        li r3 <- 0
                        beq r1 r3 lt_false
                        beq r2 r3 lt_false
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        ;; place the sum of the type tags in r1
                        add r1 <- r1 r2
                        li r2 <- 0
                        beq r1 r2 lt_bool
                        li r2 <- 2
                        beq r1 r2 lt_int
                        li r2 <- 6
                        beq r1 r2 lt_string
                        ;; for non-primitives, < is always false
lt_false:               ;; not less than
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        jmp lt_end
lt_true:                ;; less than
                        ;; new Bool
                        push fp
                        push r0
                        la r2 <- Bool..new
                        call r2
                        pop r0
                        pop fp
                        li r2 <- 1
                        st r1[3] <- r2
                        jmp lt_end
lt_bool:                ;; two Bools
lt_int:                 ;; two Ints
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        blt r1 r2 lt_true
                        jmp lt_false
lt_string:              ;; two Strings
                        ld r1 <- fp[3]
                        ld r2 <- fp[2]
                        ld r1 <- r1[3]
                        ld r2 <- r2[3]
                        ld r1 <- r1[0]
                        ld r2 <- r2[0]
                        blt r1 r2 lt_true
                        jmp lt_false
lt_end:                 pop ra
                        li r2 <- 2
                        add sp <- sp r2
                        return
;;end helper subroutines;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;ENTRY POINT HERE;;;;;;;;;;;;;;;;
start:
	push fp
	la r2 <- Main..new
	call r2
	push fp
	push r1
	la r2 <- Main.main
	call r2
	syscall exit

