#include <fstream>
#include "gtest/gtest.h"
#include "ParserDriver.hh"
#include "type.h"
using namespace std;

/**
 * Currently, the googletest tests executable is in /CoolCompilerProject/cmake-build-debug/tests. Going to root
 * of project is two directories back
 */
const string tests_EXE_TO_ROOT = "../../";
const string RESOURCES_DIR_FROM_ROOT = "tests/resources/";
const string COOL_PROGRAMS_DIR_FROM_RESOURCES = "CoolPrograms/";
const string tests_EXE_TO_COOL_PROGRAMS = tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + COOL_PROGRAMS_DIR_FROM_RESOURCES;
const string CD = "cd ";


stringstream makeTypeStringStreamFromReference(string fileName) {
    //generate the reference output
    string commandGenerateReference = CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && ./cool --type " + COOL_PROGRAMS_DIR_FROM_RESOURCES + fileName;
    system(commandGenerateReference.c_str());

    //read reference output into an ifstream
    ifstream referenceLexerOutput(tests_EXE_TO_COOL_PROGRAMS + fileName + "-type");

    //make it a stringstream so we can compare
    stringstream s;
    s << referenceLexerOutput.rdbuf();
    return s;
}

const int CLASS_MAP_OPTION = 1;
const int IMPLEMENTATION_MAP_OPTION = 2;
const int PARENT_MAP_OPTION = 3;
const int ANNOTATED_AST_OPTION = 4;
/**
 * The .cl-type generated by the reference compiler has four sections in the following order: <br/>
 * 1. class map <br/>
 * 2. implementation map <br/>
 * 3. parent map <br/>
 * 4. annotated AST <br/>
 * @param fileName
 * @param section: use defined constants
 * @return
 */
stringstream makeSingleSectionFromReference(string fileName, int section) {
    //generate the reference output
    string commandGenerateReference = CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && ./cool --type " + COOL_PROGRAMS_DIR_FROM_RESOURCES + fileName;
    system(commandGenerateReference.c_str());

    //read reference output into an ifstream
    ifstream referenceLexerOutput(tests_EXE_TO_COOL_PROGRAMS + fileName + "-type");

    //convert appropriate section to string stream
    int numPairs;
    stringstream s;
    string temp;
    getline(referenceLexerOutput, temp); //always need the first line, it's like initializing all the while loops in the cases
    switch(section) {
        case 1:
            while(temp != "implementation_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 2:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            //at this point, temp has "implementation_map"
            //another temp comparison which will always fail on the first time
            while(temp != "parent_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 3:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            //same logic as case 2. temp has "parent_map"
            //but fourth section has no marker, so we need to use info about third section to see how many times we loop
            s << temp << endl;
            getline(referenceLexerOutput, temp);
            //parent map listed as pairs, on separate lines
            numPairs = atoi(temp.c_str());
            s << numPairs << endl;
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                s << temp << endl;
                getline(referenceLexerOutput, temp);
                s << temp << endl;
            }
            break;
        case 4:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            getline(referenceLexerOutput, temp);
            numPairs = atoi(temp.c_str());
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                getline(referenceLexerOutput, temp);
            }
            while(getline(referenceLexerOutput, temp)) {
                s << temp << endl;
            }
            break;
    }
    return s;
}

/**
 * Test fixture for all type tests.
 */
class classMapTypeTests : public testing::TestWithParam<string> {
protected:
    ParserDriver pdrv;
    stringstream semanticAnalyzerOutput;
    stringstream reference;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
        populateClassMap();
        populateParentMap();
        populateImplementationMap();
        //generate reference stringstream
    }

    void TearDown() override {
        globalEnv->reset();
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
    }

};
//====================BEGIN CLASSMAPTESTS===================================
TEST_P(classMapTypeTests, matchesReferenceClassMap) {
    reference = makeSingleSectionFromReference(GetParam(), CLASS_MAP_OPTION);

    printClassMap(semanticAnalyzerOutput);
    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
}
INSTANTIATE_TEST_SUITE_P(classMap, classMapTypeTests, testing::Values(
        "classMapNoInitializations.cl",
        "classMapNoInitializationsWith1Inheritance.cl",
        "classMapNoInitializationsWith2Inheritance.cl",
        "classMapNoInitializationsWithMoreInheritance.cl",
        "playground.cl"));
//====================END CLASSMAPTESTS===================================

//TODO delete when not longer using
void makeTempsForDiff(string ref, string actual) {
    ofstream refOS{tests_EXE_TO_COOL_PROGRAMS + "tempRef.txt"};
    ofstream actualOS{tests_EXE_TO_COOL_PROGRAMS + "tempActual.txt"};
    refOS << ref;       refOS.close();
    actualOS << actual; actualOS.close();
}
//====================BEGIN TYPEFULLTESTS===================================
/**
 * Test fixture for all positive type tests.
 */
class typeTests : public testing::TestWithParam<string> {
protected:
    ParserDriver pdrv;
    stringstream semanticAnalyzerOutput;
    stringstream reference;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);


        //generate reference stringstream
        reference = makeTypeStringStreamFromReference(GetParam());
    }

    void TearDown() override {
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
        globalEnv->reset();
        errorLog.clear();
    }

};
TEST_P(typeTests, matchesReferenceFull) {
    populateClassMap();
    populateImplementationMap();
    populateParentMap();
    AST->traverse();
    printClassMap(semanticAnalyzerOutput);
    printImplementationMap(semanticAnalyzerOutput);
    printParentMap(semanticAnalyzerOutput);
    semanticAnalyzerOutput << *AST;
//    AST->prettyPrint(cout, "");

    makeTempsForDiff(reference.str(), semanticAnalyzerOutput.str());

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
}
INSTANTIATE_TEST_SUITE_P(Fragments, typeTests, testing::Values(
                            "classMapNoInitializations.cl",
                            "assignExpr.cl",
                            "caseExprOneCase.cl",
                            "caseExprManyCase.cl",
                            "ifExpression.cl",
                            "ifWhileExpressions.cl",
                            "letExprOneBindingNoInit.cl",
                            "letExprOneBindingYesInit.cl",
                            "letExprMultipleBindingMixedInit.cl",
                            "isvoidExpr.cl",
                            "staticDispatchExpr.cl",
                            "staticDispatchExpr2.cl",
                            "selfDispatchExpr.cl",
                            "dynamicDispatchExpr.cl",
                            "SELF_TYPE.cl",
                            "identifierExpr.cl",
                            "classMapNoInitializations.cl",
                            "assignMismatchButConforms.cl"));
INSTANTIATE_TEST_SUITE_P(TypeFull, typeTests, testing::Values(
                            "arith.cl",
                            "atoi.cl",
                            "cells.cl",
                            "hello-world.cl",
                            "hs.cl",
                            "list.cl",
                            "new-complex.cl",
                            "primes.cl",
                            "print-cool.cl",
                            "sort-list.cl"));
//====================END TYPEFULLTESTS===================================
//====================BEGIN NEGATIVETYPETESTS===================================
pair<int, string> makeErrorPairFromReference(string fileName) {
    //generate the reference pair
    string commandGenerateReference = CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && ./cool --type " + COOL_PROGRAMS_DIR_FROM_RESOURCES + fileName;
    string appendStdoutRedirect = " > temp.txt";
    system((commandGenerateReference + appendStdoutRedirect).c_str());

    ifstream cmdLineRedirectResult(tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + "temp.txt");
    //Example output:
    //ERROR: 0: Type-Check: class Main method main with 0 parameters not found
    pair<int, string>returnThis;

    string temp;
    getline(cmdLineRedirectResult, temp, ':');
    cmdLineRedirectResult.ignore(); //go forward one character, the space betwween ERROR: and 0
    getline(cmdLineRedirectResult, temp, ':');
    returnThis.first = stoi(temp);
    getline(cmdLineRedirectResult, temp, ':');
    getline(cmdLineRedirectResult, temp);
    returnThis.second = temp;

    cmdLineRedirectResult.close();
    string command = (CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && rm temp.txt"); //delete the temp
    system(command.c_str());
    return returnThis;
}
class negativeTypeTests : public testing::TestWithParam<string> {
protected:
    ParserDriver pdrv;

    /**
     * To report an error, write the string
       ERROR: line_number: Type-Check: message
       to standard output and terminate the program. You may write whatever you want in the message, but it should be fairly indicative.
     */
    pair<int, string> refError;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
        populateClassMap();
        populateImplementationMap();
        populateParentMap();
        //generate reference error
        refError = makeErrorPairFromReference(GetParam());
    }

    void TearDown() override {
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
        globalEnv->reset();
        errorLog.clear();
    }
};

/**
 * The reference compiler reports only the first error it finds, so test cases must be restricted to a single error.
 * Providing error messages, but only checking line numbers for "correctness" of the test case.
 */
TEST_P(negativeTypeTests, matchesReferenceError) {
    cout << refError.first << ", " << refError.second << endl;
    AST->traverse();
    ASSERT_EQ(errorLog[0].first, refError.first);
}
INSTANTIATE_TEST_SUITE_P(Class, negativeTypeTests, testing::Values(
                            "semanticAnalyzerNegative/class/inheritString.cl",
                            "semanticAnalyzerNegative/class/noMainClass.cl",
                            "semanticAnalyzerNegative/class/inheritBool.cl",
                            "semanticAnalyzerNegative/class/inheritInt.cl"));
INSTANTIATE_TEST_SUITE_P(Method, negativeTypeTests, testing::Values(
                            "semanticAnalyzerNegative/method/parameter-less_main_Main.cl"));
INSTANTIATE_TEST_SUITE_P(Expression, negativeTypeTests, testing::Values(
                            "semanticAnalyzerNegative/expression/arithAll.cl",
                            "semanticAnalyzerNegative/expression/arithDivide.cl",
                            "semanticAnalyzerNegative/expression/arithMinus.cl",
                            "semanticAnalyzerNegative/expression/arithPlus.cl",
                            "semanticAnalyzerNegative/expression/arithTImes.cl",
                            "semanticAnalyzerNegative/expression/ASSIGN.cl",
                            "semanticAnalyzerNegative/expression/if.cl",
                            "semanticAnalyzerNegative/expression/loop.cl",
                            "semanticAnalyzerNegative/expression/negate.cl",
                            "semanticAnalyzerNegative/expression/not.cl",
                            "semanticAnalyzerNegative/expression/equalInt.cl",
                            "semanticAnalyzerNegative/expression/ltInt.cl",
                            "semanticAnalyzerNegative/expression/lteInt.cl",
                            "semanticAnalyzerNegative/expression/equalString.cl",
                            "semanticAnalyzerNegative/expression/ltString.cl",
                            "semanticAnalyzerNegative/expression/lteString.cl",
                            "semanticAnalyzerNegative/expression/equalBool.cl",
                            "semanticAnalyzerNegative/expression/ltBool.cl",
                            "semanticAnalyzerNegative/expression/lteBool.cl",
                            "semanticAnalyzerNegative/expression/let-init.cl",
                            "semanticAnalyzerNegative/expression/attr-init.cl"));



/**
 * Type and semantic checks defined by me, not the reference compiler
 */
class negativeTypeTestsNoRef : public testing::TestWithParam<string> {
private:
    /**
     * In folder expectedKeys
     * @return
     */
protected:
    map<string, pair<int,string>> expectedErrorsMap{
            {"let0Identifiers.cl", {3, "Let expression introduces 0 identifiers\n"}},
            {"letRepeatIdentifier.cl", {5, "x is defined more than once in this let expression.\n"}},
            {"case0Cases.cl", {3, "\n"}},
            {"caseRepeatTypes.cl", {3, "\n"}},
            {"block0Subexpressions.cl", {3, "\n"}}
    };

    ParserDriver pdrv;

    /**
     * To report an error, write the string
       ERROR: line_number: Type-Check: message
       to standard output and terminate the program. You may write whatever you want in the message, but it should be fairly indicative.
     */
    pair<int, string> expectedError;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
        populateClassMap();
        populateImplementationMap();
        populateParentMap();
        //generate expected error
        string onlyFileName = GetParam();
        onlyFileName = onlyFileName.substr(string{"semanticAnalyzerNegative/expression/"}.size(), onlyFileName.size());
        expectedError = expectedErrorsMap.at(onlyFileName);
    }

    void TearDown() override {
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
        globalEnv->reset();
        errorLog.clear();
    }
};
TEST_P(negativeTypeTestsNoRef, errorsNotInReferenceCompiler) {
    AST->traverse();
    ASSERT_EQ(errorLog[0].first, expectedError.first);
}
INSTANTIATE_TEST_SUITE_P(ivanErrors, negativeTypeTestsNoRef, testing::Values(
                            "semanticAnalyzerNegative/expression/let0Identifiers.cl",
                            "semanticAnalyzerNegative/expression/letRepeatIdentifier.cl",
                            "semanticAnalyzerNegative/expression/case0Cases.cl",
                            "semanticAnalyzerNegative/expression/caseRepeatTypes.cl",
                            "semanticAnalyzerNegative/expression/block0Subexpressions.cl"));
