#include <fstream>
#include "gtest/gtest.h"
#include "ParserDriver.hh"
#include "type.h"
using namespace std;

/**
 * Currently, the googletest tests executable is in /CoolCompilerProject/cmake-build-debug/tests. Going to root
 * of project is two directories back
 */
const string tests_EXE_TO_ROOT = "../../";
const string RESOURCES_DIR_FROM_ROOT = "tests/resources/";
const string COOL_PROGRAMS_DIR_FROM_RESOURCES = "CoolPrograms/";
const string tests_EXE_TO_COOL_PROGRAMS = tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + COOL_PROGRAMS_DIR_FROM_RESOURCES;
const string CD = "cd ";


stringstream makeTypeStringStreamFromReference(string fileName) {
    //generate the reference output
    string commandGenerateReference = CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && ./cool --type " + COOL_PROGRAMS_DIR_FROM_RESOURCES + fileName;
    system(commandGenerateReference.c_str());

    //read reference output into an ifstream
    ifstream referenceLexerOutput(tests_EXE_TO_COOL_PROGRAMS + fileName + "-type");

    //make it a stringstream so we can compare
    stringstream s;
    s << referenceLexerOutput.rdbuf();
    return s;
}

const int CLASS_MAP_OPTION = 1;
const int IMPLEMENTATION_MAP_OPTION = 2;
const int PARENT_MAP_OPTION = 3;
const int ANNOTATED_AST_OPTION = 4;
/**
 * The .cl-type generated by the reference compiler has four sections in the following order: <br/>
 * 1. class map <br/>
 * 2. implementation map <br/>
 * 3. parent map <br/>
 * 4. annotated AST <br/>
 * @param fileName
 * @param section: use defined constants
 * @return
 */
stringstream makeSingleSectionFromReference(string fileName, int section) {
    //generate the reference output
    string commandGenerateReference = CD + tests_EXE_TO_ROOT + RESOURCES_DIR_FROM_ROOT + " && ./cool --type " + COOL_PROGRAMS_DIR_FROM_RESOURCES + fileName;
    system(commandGenerateReference.c_str());

    //read reference output into an ifstream
    ifstream referenceLexerOutput(tests_EXE_TO_COOL_PROGRAMS + fileName + "-type");

    //convert appropriate section to string stream
    int numPairs;
    stringstream s;
    string temp;
    getline(referenceLexerOutput, temp); //always need the first line, it's like initializing all the while loops in the cases
    switch(section) {
        case 1:
            while(temp != "implementation_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 2:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            //at this point, temp has "implementation_map"
            //another temp comparison which will always fail on the first time
            while(temp != "parent_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 3:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            //same logic as case 2. temp has "parent_map"
            //but fourth section has no marker, so we need to use info about third section to see how many times we loop
            s << temp << endl;
            getline(referenceLexerOutput, temp);
            //parent map listed as pairs, on separate lines
            numPairs = atoi(temp.c_str());
            s << numPairs << endl;
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                s << temp << endl;
                getline(referenceLexerOutput, temp);
                s << temp << endl;
            }
            break;
        case 4:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            getline(referenceLexerOutput, temp);
            numPairs = atoi(temp.c_str());
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                getline(referenceLexerOutput, temp);
            }
            while(getline(referenceLexerOutput, temp)) {
                s << temp << endl;
            }
            break;
    }
    return s;
}

/**
 * Test fixture for all type tests.
 */
class classMapTypeTests : public testing::TestWithParam<string> {
protected:
    ParserDriver pdrv;
    stringstream semanticAnalyzerOutput;
    stringstream reference;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
        AST->traverse();
        populateClassMap();
        populateImplementationMap();
        populateParentMap();
        //generate reference stringstream
    }

    void TearDown() override {
        globalEnv->reset();
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
    }

};
//====================BEGIN CLASSMAPTESTS===================================
TEST_P(classMapTypeTests, matchesReferenceClassMap) {
    reference = makeSingleSectionFromReference(GetParam(), CLASS_MAP_OPTION);

    printClassMap(semanticAnalyzerOutput);
    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
}
INSTANTIATE_TEST_SUITE_P(classMap, classMapTypeTests, testing::Values(
        "classMapNoInitializations.cl",
        "classMapNoInitializationsWith1Inheritance.cl",
        "classMapNoInitializationsWith2Inheritance.cl",
        "classMapNoInitializationsWithMoreInheritance.cl",
        "playground.cl"));
//====================END CLASSMAPTESTS===================================
//====================BEGIN IMPLEMENTATIONMAPTESTS===================================
//Not using any fixture
TEST(implementationMapTests, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";

    stringstream semanticAnalyzerOutput;
    pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();//implementationMap requires having already traversed the tree and decorating nodes, like giving expressions a type and type checking

    populateImplementationMap();
    printImplementationMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, IMPLEMENTATION_MAP_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();
}
//====================END IMPLEMENTATIONMAPTESTS===================================
//====================BEGIN ANNOTATEDASTTESTS===================================
//Not using any fixture
TEST(AnnotatedASTTests, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";

    stringstream semanticAnalyzerOutput;
    pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();
    semanticAnalyzerOutput << *AST;

    stringstream reference = makeSingleSectionFromReference(localFile, ANNOTATED_AST_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();
}
TEST(AnnotatedASTTests, identifierExpr) {
    ParserDriver pdrv;
    const string localFile = "identifierExpr.cl";

    stringstream semanticAnalyzerOutput;
    pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();
    semanticAnalyzerOutput << *AST;

    stringstream reference = makeSingleSectionFromReference(localFile, ANNOTATED_AST_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();
}
//====================END ANNOTATEDASTTESTS===================================
//====================BEGIN TYPEFULLTESTS===================================
/**
 * Test fixture for all type tests.
 */
class typeTests : public testing::TestWithParam<string> {
protected:
    ParserDriver pdrv;
    stringstream semanticAnalyzerOutput;
    stringstream reference;

    _program* AST;

    void SetUp() override {
        //parse the input into global parse tree rootIVAN
        pdrv.parse(tests_EXE_TO_COOL_PROGRAMS + GetParam());
        //build syntax tree out of rootIVAN
        AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);


        //generate reference stringstream
        reference = makeTypeStringStreamFromReference(GetParam());
    }

    void TearDown() override {
        globalEnv->reset();
        classMap.clear();
        implementationMap.clear();
        parentMap.clear();
    }

};
TEST_P(typeTests, matchesReferenceFull) {
    populateClassMap();
    populateImplementationMap();
    populateParentMap();
    AST->traverse();
    printClassMap(semanticAnalyzerOutput);
    printImplementationMap(semanticAnalyzerOutput);
    printParentMap(semanticAnalyzerOutput);
    semanticAnalyzerOutput << *AST;

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
}
INSTANTIATE_TEST_SUITE_P(Fragments, typeTests, testing::Values(
                            "classMapNoInitializations.cl",
                            "assignExpr.cl",
                            "caseExprOneCase.cl",
                            "caseExprManyCase.cl"));
INSTANTIATE_TEST_SUITE_P(TypeFull, typeTests, testing::Values(
//                            "arith.cl",
                            "atoi.cl",
                            "cells.cl",
                            "hello-world.cl",
//                            "hs.cl",
                            "list.cl",
                            "new-complex.cl",
                            "primes.cl",
                            "print-cool.cl",
                            "sort-list.cl"));
//====================END TYPEFULLTESTS===================================