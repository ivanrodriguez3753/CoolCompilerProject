#include <fstream>
#include "gtest/gtest.h"
#include "parser.hh"
#include "ParserDriver.hh"
#include "type.h"
using namespace std;

const string RESOURCES_DIR = "../../tests/resources/";
const string COOL_PROGRAMS_DIR = RESOURCES_DIR + "CoolPrograms/";

stringstream makeTypeStringStreamFromReference(string fileName) {
    //generate the reference output
    string command = "cd " + RESOURCES_DIR + " && ./cool --type CoolPrograms/" + fileName;
    system(command.c_str());

    //read reference output into an ifstream
    string clLexFilePath = RESOURCES_DIR + "CoolPrograms/" + fileName + "-type";
    ifstream referenceLexerOutput(clLexFilePath);

    //make it a stringstream so we can compare
    stringstream s;
    s << referenceLexerOutput.rdbuf();
    return s;
}

const int CLASS_MAP_OPTION = 1;
const int IMPLEMENTATION_MAP_OPTION = 2;
const int PARENT_MAP_OPTION = 3;
const int ANNOTATED_AST_OPTION = 4;


/**
 * The .cl-type generated by the reference compiler has four sections in the following order:
 * 1. class map
 * 2. implementation map
 * 3. parent map
 * 4. annotated AST
 * Use defined constants
 */
stringstream makeSingleSectionFromReference(string filename, int section) {
    //generate the reference output
    string command = "cd " + RESOURCES_DIR + " && ./cool --type CoolPrograms/" + filename;
    system(command.c_str());

    //read reference output into an ifstream
    string clLexFilePath = RESOURCES_DIR + "CoolPrograms/" + filename + "-type";
    ifstream referenceLexerOutput(clLexFilePath);

    //convert appropriate section to string stream
    int numPairs;
    stringstream s;
    string temp;
    getline(referenceLexerOutput, temp); //always need the first line, it's like initializing all the while loops in the cases
    switch(section) {
        case 1:
            while(temp != "implementation_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 2:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            //at this point, temp has "implementation_map"
            //another temp comparison which will always fail on the first time
            while(temp != "parent_map") {
                s << temp << endl;
                getline(referenceLexerOutput, temp);
            }
            break;
        case 3:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            //same logic as case 2. temp has "parent_map"
            //but fourth section has no marker, so we need to use info about third section to see how many times we loop
            s << temp << endl;
            getline(referenceLexerOutput, temp);
            //parent map listed as pairs, on separate lines
            numPairs = atoi(temp.c_str());
            s << numPairs << endl;
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                s << temp << endl;
                getline(referenceLexerOutput, temp);
                s << temp << endl;
            }
            break;
        case 4:
            while(temp != "implementation_map") {
                getline(referenceLexerOutput, temp);
            }
            while(temp != "parent_map") {
                getline(referenceLexerOutput, temp);
            }
            getline(referenceLexerOutput, temp);
            numPairs = atoi(temp.c_str());
            for(int i = 0; i < numPairs; i++) {
                getline(referenceLexerOutput, temp);
                getline(referenceLexerOutput, temp);
            }
            while(getline(referenceLexerOutput, temp)) {
                s << temp << endl;
            }
            break;
    }
    return s;
}

/**
 * don't test with initializations because I'm not gonna test the expr type checker until I test everything
 * altogether, since by then the AST will be done and I can determine expression for type
 */
TEST(classMap, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, CLASS_MAP_OPTION);
    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(classMap, noInitializationsWith1Inheritance) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializationsWith1Inheritance.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, CLASS_MAP_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(classMap, noInitializationsWith2Inheritance) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializationsWith2Inheritance.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, CLASS_MAP_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(classMap, noInitializationsWithMoreInheritance) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializationsWithMoreInheritance.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, CLASS_MAP_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}


TEST(classMap, playground) {
    ParserDriver pdrv;
    const string localFile = "playground.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);


    stringstream reference = makeSingleSectionFromReference(localFile, CLASS_MAP_OPTION);
    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(implementationMap, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();//implementationMap requires having already traversed the tree and decorating nodes, like giving expressions a type and type checking

    populateImplementationMap();
    printImplementationMap(semanticAnalyzerOutput);

    stringstream reference = makeSingleSectionFromReference(localFile, IMPLEMENTATION_MAP_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(AnnotatedAST, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();//implementationMap requires having already traversed the tree and decorating nodes, like giving expressions a type and type checking
    semanticAnalyzerOutput << *AST;


    stringstream reference = makeSingleSectionFromReference(localFile, ANNOTATED_AST_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(AnnotatedAST, identifierExpr) {
    ParserDriver pdrv;
    const string localFile = "identifierExpr.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();//implementationMap requires having already traversed the tree and decorating nodes, like giving expressions a type and type checking
    semanticAnalyzerOutput << *AST;


    stringstream reference = makeSingleSectionFromReference(localFile, ANNOTATED_AST_OPTION);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();}

TEST(TypeFull, noInitializations) {
    ParserDriver pdrv;
    const string localFile = "classMapNoInitializations.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    AST->traverse();
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);
    populateImplementationMap();
    printImplementationMap(semanticAnalyzerOutput);
    populateParentMap();
    printParentMap(semanticAnalyzerOutput);
    semanticAnalyzerOutput << *AST;

    stringstream reference = makeTypeStringStreamFromReference(localFile);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();
}
TEST(TypeFull, assignExpr) {
    ParserDriver pdrv;
    const string localFile = "assignExpr.cl";
    pdrv.file = COOL_PROGRAMS_DIR + localFile;

    _expr::printExprType = true;

    stringstream semanticAnalyzerOutput;
    pdrv.parse(COOL_PROGRAMS_DIR + localFile);
    _program* AST = (_program*) pdrv.buildSyntaxTree(rootIVAN);
    populateClassMap();
    printClassMap(semanticAnalyzerOutput);
    populateImplementationMap();
    AST->traverse();
    printImplementationMap(semanticAnalyzerOutput);
    populateParentMap();
    printParentMap(semanticAnalyzerOutput);
    semanticAnalyzerOutput << *AST;

    stringstream reference = makeTypeStringStreamFromReference(localFile);

    ASSERT_EQ(reference.str(), semanticAnalyzerOutput.str());
    globalEnv->reset();
    classMap.clear();
    implementationMap.clear();
    parentMap.clear();
}