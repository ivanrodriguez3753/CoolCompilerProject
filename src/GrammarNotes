double brackets means grouping, not an actual grammar symbol. Single brackets means optional


***ORIGINAL***
program ->
    [[class ;]]+
;
**************
We need to introduce a classlist nonterminal to expand the shorthand notation.
program ->
    classList
;
classList ->
    classList CLASS
|   %empty
;

Remember that this is bottom up, so in every classList, the first rule to be evaluated (perform semantic actions)
will be the empty rule.
=================================================================================================================
***ORIGINAL***
class ->
    CLASS TYPE [INHERITS TYPE] { [[feature ; ]]* }
;
**************
class nonterminal is always followed by a semicolon so go ahead and include it
in the definition for class
We need another rule for an optional inheritance. Then do something similar for the list of features as we did for
the list of classes. The + (at least one class) and *(0 or more features) are checked in the semantic analyzer
class ->
    CLASS TYPE optionalInh { featureList } ;
;

optionalInt ->
    INHERITS TYPE
|   %empty
;

featureList ->
    featureList feature
|   %empty
;
============================================================================================
***ORIGINAL***
feature ->
    ID ( [formal [[, formal]]* ] ) : TYPE { expr }
|   ID : TYPE [ <- expr ]
;
So clearly, one production is for fields and the other is for methods
These will probably carry their own information. So let's abstract these
I don't know if this will introduce shift/reduce conflicts but we'll see
feature ->
    method
|   field
;
A method has an optional list of formal parameters. First check if there are
any formals, and if so, expand into arbitrary number of them

method ->
    ID ( optionalFormalsList ) : TYPE { expr } ;
;


formalsList ->
    firstFormal moreFormalsList
|   %empty
;

firstFormal ->
    formal
;

moreFormalsList ->
    moreFormalsList , formal
|   %empty


field ->
    ID : TYPE optionalInit ;
;

optionalInit ->
    %empty
|   <- expr


========================================================================
***ORIGINAL***
formal ->
    ID : TYPE
;
There's really just nothing to do here
========================================================================


expr ->
    ID <- expr
|   expr [@TYPE].ID([ expr [[, expr]]* ] )
|   ID ( [ expr [[, expr]]* ] )
|   if expr then expr else expr fi
|   while expr loop expr pool
|   { [[expr;]]+ }
|   let ID : TYPE [ <- expr ] [[, ID : TYPE [ <0 expr ] ]]* in expr
|   case expr of [[ID : TYPE => expr;]]+ esac
|   new TYPE
|   isvoid expr
|   expr + expr
|   expr - expr
|   expr * expr
|   expr / expr
|   ~expr
|   expr < expr
|   expr <= expr
|   expr = expr
|   not expr
|   (expr)
|   ID
|   integer
|   string
|   true
|   false
;